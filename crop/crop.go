// package coverage provides methods for cropping the geometry of Who's On First records.
package crop

import (
	"context"
	"fmt"
	// "github.com/go-spatial/geom"
	// "github.com/go-spatial/geom/planar/clip"
	// "github.com/go-spatial/geom/planar/makevalid"
	// "github.com/go-spatial/geom/planar/makevalid/hitmap"
	"github.com/paulmach/orb"
	_ "github.com/paulmach/orb/clip"
	"github.com/paulmach/orb/geojson"
	"github.com/paulmach/orb/maptile"
	"github.com/sfomuseum/go-whosonfirst-tiles/geometry"
	_ "github.com/whosonfirst/go-whosonfirst-iterate/emitter"
	// "log"
)

// CropFeatureWithTile will crop the geometry of a GeoJSON Feature defined by 'body' to the extent of 'tile'.
func CropFeatureWithTile(ctx context.Context, body []byte, tile maptile.Tile) ([]byte, error) {

	bounds := tile.Bound()
	return CropFeatureWithBounds(ctx, body, bounds)
}

// CropFeatureWithTile will crop the geometry of a GeoJSON Feature defined by 'body' to the extent of 'bounds'.
func CropFeatureWithBounds(ctx context.Context, body []byte, bounds orb.Bound) ([]byte, error) {

	f, err := geojson.UnmarshalFeature(body)

	if err != nil {
		return nil, fmt.Errorf("Failed to unmarshal feature, %w", err)
	}

	/*
		clipped_geom := clip.Geometry(bounds, f.Geometry)

		if clipped_geom == nil {
			return nil, fmt.Errorf("Failed to derive clipped geometry")
		}

		f.Geometry = clipped_geom
	*/

	/*
		geom_geometry, err := geometry.OrbToGeom(ctx, f.Geometry)

		if err != nil {
			return nil, fmt.Errorf("Failed to convert orb geometry to geom geometry, %w", err)
		}

		geom_bounds, err := geometry.OrbToGeom(ctx, bounds.ToPolygon())

		if err != nil {
			return nil, fmt.Errorf("Failed to convert orb bounds to geom geometry, %w", err)
		}

		geom_extent, err := geom.NewExtentFromGeometry(geom_bounds)

		if err != nil {
			return nil, fmt.Errorf("Failed to create extent from bounds, %w", err)
		}

		// This doesn't work with Polygons, because... ?
		// geom_cropped, err := clip.Geometry(ctx, geom_geometry, geom_extent)

		hm, err := hitmap.New(geom_extent, geom_geometry)

		if err != nil {
			return nil, fmt.Errorf("Failed to create hitmap, %w", err)
		}

		mv := &makevalid.Makevalid{
			Hitmap: hm,
		}

		geom_cropped, did_clip, err := mv.Makevalid(ctx, geom_geometry, geom_extent)

		if err != nil {
			return nil, fmt.Errorf("Failed to crop geometry, %w", err)
		}

		if !did_clip {
			return body, nil
		}

		// panic: value method github.com/go-spatial/geom.MultiPolygon.Polygons called using nil *MultiPolygon pointer
		// goroutine 7 [running]:
		// github.com/go-spatial/geom.(*MultiPolygon).Polygons(0x0, 0x2, 0x2, 0x5d551f0)
		// <autogenerated>:1 +0x50
		// github.com/go-spatial/geom/encoding/wkb/internal/encode.(*Encoder).Geometry(0xc00019d4c8, 0x46cc180, 0x0)
		// /usr/local/sfomuseum/go-whosonfirst-tiles/vendor/github.com/go-spatial/geom/encoding/wkb/internal/encode/encode.go:145 +0x399
		// github.com/go-spatial/geom/encoding/wkb.EncodeWithByteOrder(0x4822228, 0x4b938a8, 0x4813da0, 0xc0004461e0, 0x46cc180, 0x0, 0xb, 0x0)
		// /usr/local/sfomuseum/go-whosonfirst-tiles/vendor/github.com/go-spatial/geom/encoding/wkb/wkb.go:95 +0x85
		// github.com/go-spatial/geom/encoding/wkb.Encode(...)

		// path, _ := emitter.PathForContext(ctx)
		// log.Printf("CONVERT %s: %T\n", path, geom_cropped)

		orb_cropped, err := geometry.GeomToOrb(ctx, geom_cropped)

		if err != nil {
			return nil, fmt.Errorf("Failed to convert geom geometry to orb geometry, %w", err)
		}

	*/

	source_geom, err := geometry.OrbToGeos(ctx, f.Geometry)

	if err != nil {
		return nil, fmt.Errorf("Failed to create geos geometry, %w", err)
	}

	clip_geom, err := geometry.OrbToGeos(ctx, bounds.ToPolygon())

	if err != nil {
		return nil, fmt.Errorf("Failed to create geos geometry for bounds, %w", err)
	}

	cropped_geom, err := source_geom.Intersection(clip_geom)

	if err != nil {
		return nil, fmt.Errorf("Failed to intersect geometry, %w", err)
	}

	orb_cropped, err := geometry.GeosToOrb(ctx, cropped_geom)

	if err != nil {
		return nil, fmt.Errorf("Failed to create orb geometry for crop, %w", err)
	}

	f.Geometry = orb_cropped

	return f.MarshalJSON()
}
